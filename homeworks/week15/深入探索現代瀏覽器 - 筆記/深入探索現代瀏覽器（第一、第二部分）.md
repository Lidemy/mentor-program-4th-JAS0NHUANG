[Inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part1)

# 深入探索現代瀏覽器（第一部分）

## 中央處理器、圖形處理器、記憶體與多程序架構（文章內容是什麼）
文章會從上層的架構講到渲染管線。
瞭解瀏覽器如何將原始碼轉換成「網頁」，為什麼選擇某種技術對效能有影響。
先看看電腦名詞以及「鉻」（Chrome）的多程序架構

## 電腦的核心：中央處理器、圖形處理器
中央處理器是電腦的腦，單核，多核。16 核、32 核……

圖形處理器拿來算圖，多多多核。上百、上千個「統一計算架構」（CUDA）核心。

硬體 -> 作業系統 -> 應用程式

## 程序與執行緒
一個程序可以想像成一個執行中的程式，執行緒則是這個執行中程式（程序）裡的一些個別任務。
打開一個應用程式就會開啟一個「程序」，電腦會給予這個程序可以使用的一些記憶體，應用程式被關閉的時候就會交還記憶體的使用權。

## 瀏覽器架構
有兩種：
  1. 一個程序裡包含很多執行緒。
  2. 很多程序，內部分別有比較少的執行緒，而各程序之間經由「程序間通訊」（IPC）與彼此溝通。
「鉻」屬於第二種，一個瀏覽器程序做為啟動程序，它與工具程序、圖形處理器程序、渲染程序、外掛程序一起工作。
渲染程序就是畫出每個標籤頁的程序，一個標籤頁就會有一個程序，（現在好像是每個「網站」會有一個程序）

程序分工：
- 瀏覽器程序：瀏覽器的使用介面，網路請求，檔案讀寫……
- 渲染程序：每個標籤頁裡頁面的渲染
- 外掛：控制網頁用到的外掛，像 「閃光」（Flash）
- 圖形處理器：獨立控制繪圖工作，它會接收來自不同程序的請求（包括非「鉻」的請求），然後顯示在螢幕上。

其實還有很多其它程序，可以點一下丸子三兄弟，找到「更多工具」->「程序管理員」。（記憶體終結者是也！XD）

## 多程序的好處
「鉻」使用多重渲染程序，一個標籤頁就是一個渲染程序。
第一個好處就是當一個標籤頁當掉的時候不會影響其它標籤頁。 
第二個好處就是有沙箱的效果，比較安全，每個標籤頁可以有自已的使用限制。（不太清楚 arbitrary file access 與 arbitrary user input 是在講什麼……）  

雖然有上面講到的好處，但是因為每個程序是獨立的，所以沒辦法像單一程序一樣分享記憶體的空間，所以會更消耗記憶體。因此「鉻」會根據使用者的電腦資源（中央處理器、圖形第理器、記憶體多寡）來設定一個上限，當到達上限時就會開始將多個標籤頁開在同一個程序上。

## 「服務化」
在資源充足的電腦上，「鉻」會把每個瀏覽器功能當成一個「服務程序」，這可以讓瀏覽器的運行更穩定；但是在資源不足的電腦上，則會把多個功能包在同一個程序中以減少資源消秏。

## 單框格渲染程序 - 網站隔離
這裡的「框格」指的是 iframe 的框格，也就是在同一個標籤頁裡（ 或者同一個網頁裡）嵌入另一個網頁的「框格」。
「鉻」現在預設會把這些框格都用不同的程序處理，這樣一來即便網站試圖規避同源政也無法拿到資料。（實際運作細節不清楚……）
網站隔離也不單純是用不同程序處理不同框格，它還改變了各個框格彼此之間的溝通模式，使用 DevTools、內容搜尋等功能都需要有許多工程上更細節的解決方法（ 什麼解決方法也沒講……反正就是很厲害就對了）

第一部分瞭解了上層架構，

# 深入探索現代瀏覽器（第二部分）
## 「瀏覽」這件事
來看看使用者送出請求，以及瀏覽器渲染頁面的過程，也就是俗稱的「瀏覽」這件事。

## 從瀏覽器程序開始
是誰來處理這些事情呢？

### 第一步、處理使用者輸入
這是由「使用者介面執行緒」來處理的，因為「鉻」的網址列也是搜尋列，所以它要先判斷使用者輸入的是「網址」還是「搜尋字串」才能決定是要導向網站或是搜尋引擎。

## 第二步、導向網站
如果使用者輸入的是一個網址，「使用者介面執行緒」就會呼叫「網路執行緒」，網路執行緒就會進行網路相關的工作，像是聯絡「域名伺服器」、建立傳輸層連線、接收伺服器回應……等等，如果它接到一個「三零一」轉址回應，它就會通知使用者介面執行緒，就會再送出另一個網址請求。

## 第三步、讀取伺服器回應
開始接到回應的「身體」（實際數據），「頭部」裡面的「內容類型」會指出資料的類型，但是可能有錯漏，所以這裡會進行 MIME 類型探測……
如果內容是 HTML 檔，資料就會被傳給渲染程序，如果是壓縮檔或其它檔案，代表是一個下載請求，就會被傳給下載管理。  
這裡也會進行瀏覽安全檢查，看看是不是進到壞壞的網站；「阻擋跨域請求」會擋住跨站資料進入渲染程序。

## 第四步、找一個渲染程序（文章裡寫成第三步了……）
上面的檢查完成，確認網站沒有問題，網路執行緒就會告訴使用者介面執行緒說資料已經準備好了，使用者介面就會找到一個渲染程序進行網頁渲染。   
因為網路請求可能會花不少時間才能收到回應，所以瀏覽器會有一些優化，因為在第二步「使用者介面執行緒」在呼叫「網路執行緒」的時候就已經「大概」知道會導向那一個網站，所以在網路執行緒傳送請求的同時使用者介面也會先準備好渲染程序，如果一切順利的話，當網路執行緒收到回應時渲染程序就已經準備好可以上場了（球隊小幅領先時，八局就要先叫終結者熱身嘛！），如果收到的回應是轉向不同網域的話，那這個準備好的程序也可能不會派上用場。

## 第五步、提交瀏覽
當網路回應資料與渲染程序都準備好的時候，瀏覽器程序就會向渲染程序傳送一個「程序間通訊」（IPC），同時也會傳送接收到的資料給渲染程序。瀏覽器程序確認渲染程序已經收到這個提交後，就會進入文件載入階段。
這時候關於網站的相關資料也會載入到瀏覽器裡，像是網址列內容、安全性內容、網站介面設定、session history 也會被更新（讓上一頁、下一頁按鈕生效），session history 會被存在使用者硬碟裡以便下次開啟標籤頁時能回復原來的 session 狀態。

## 更多步驟、初始載入結束
在渲染程序完成它的工作之後，它就會回傳一個「頁面已載入」的「程序間訊息」（IPC）給瀏覽器程序，「鉻」標籤頁上「載入中」的動畫就會停止啦！  
這只是「初始載入」結束，JavaScript 可能在背景還在進行別的工作。

## 瀏覽不同網站
會先檢查有沒有 `beforeunload` 事件。就是那個會跳出「確定要離開網頁」警告訊息的東西。
** 警告：這個 `beforeunload` 不要亂加，只有在真的必要時再加！！！

## 關於「服務工作」（Service Worker）
老師一說「可以跳過、不要看、太複雜」感覺就是應該看一下……
找到這篇文章，好好看阿：[Service Worker, what are you ?](https://medium.com/@kosamari/service-worker-what-are-you-ca0f8df92b65)，同樣是 Mariko Kosaka 的文章，我沒有真的很仔細看完就是了。
還有這一篇：[服務工作線程：簡介](https://developers.google.com/web/fundamentals/primers/service-workers?hl=zh-tw] （Google 官方的翻譯阿！）
總之這個「服務工作」就是一些 JavaScript 程式，幫助處理網頁載入工作，它會選擇是要直接從快取載入資料，或者是請求網路上的資料。

## 瀏覽預載入
服務工作有時候會造成延遲，「瀏覽預載入」機制會在「服務工作」工作的同時載入資料，這樣如果「服務工作」決定從網路載入資料的話就資料就已經準備好了。
