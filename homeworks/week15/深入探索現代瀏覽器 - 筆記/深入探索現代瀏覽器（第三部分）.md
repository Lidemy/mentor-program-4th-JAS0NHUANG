[Inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part3)

# 深入探索現代瀏覽器（第三部分）

## 渲染程序的內部工作機制
與「速度」表現很有關係。

## 渲染程序處理網路資料
渲染程序的主要工作就是：**將 HTML、CSS 與 JavaScript 檔案轉化為可以跟使用者互動的網頁。**
渲染程序內有：
  - 主執行緒：處理大部分的程式碼
  - 工作執行緒：網路工作、服務工作……
  - 合成執行緒（compositor thread）
  - 光柵執行緒（raster thread）(不知道是啥……)

## 解析
### 建構 DOM
解析 HTML 文字並轉化為 DOM。
DOM 是瀏覽器內部的網頁資料，同時也是 JavaScript 可以操作、互動的資料結構與 API。
HTML 檔寫很爛瀏覽器還是可以正常解析！

### 載入其它資源
像是 img link……等等資源。有一個「預載入掃描」機制，先找到這些需要另外請求的資料，在建構 DOM 的同時進行載入。（而不是每次解析到相關資源時才進行請求、載入）

### JavaScript 可能會讓解析過程卡住
遇到 JavaScript 就會停下來處理完再繼續，因為 JavaScript 有可能會對 DOM 造成改變。
如果沒有打算修改 DOM （像是使用 `document.write()`），那我們可以加上 async 或 defer 屬性，避免卡卡。當然如果 JavaScript 超重要，也可以用 JavaScript module 叫瀏覽器快點載入。

### 樣式計算機
DOM 建構好了之後，要加上樣式了。在每個 DOM 節點加上一計算過的樣式，就算我們沒有寫 CSS，瀏覽器還是會自動幫他們加上預設的樣式。

### 佈局
算好樣式之後還不夠，還要知道每個東西放在哪裡，框格大小、字體大小……等等，這時候就要建立一個「佈局樹」

### 繪製
有了 DOM、樣式、佈局之後，接下來要決定繪製的順序。像是 z-index。
主執行緒會查找佈局樹然後建立繪製記錄，也就是決定繪製流程的東西。更新渲染流程是很耗資源的，這個流程就如上面所說：樣式-> 佈局 -> 繪製
關於每秒 60 格的問題，如果中間缺一、兩格頁面就會有「剪奇」（janky）的感覺（電影一秒才 24 格，不到 60 格的一半，所以其實如果不掉超過兩格的話肉眼應該是沒辦法真的很明確的分辨出來，但是「感覺」上應該還是會有些差異。）
總之，如果要避免 JavaScript 造成卡卡的話，可以使用 `requestAnimationFrame()` 讓 JavaScript 的運算平均分配到每次個影格顯示的間隔中。

## 合成
### 怎樣繪出一個頁面
過去的方法：在可見框格中（viewport）繪出內容，然後當使用者捲動畫面時，因為可見框格變動，再繪出相應的內容。但是現代瀏覽器有更複雜的程序：合成。

### 什麼是「合成」
它由「合成執行緒」負責，工作就是將網頁的每個元素分別處理，然後最後組合成一個頁面，這樣一來，如果使用者捲動畫面，它只要將可見框格移到另一個區塊就好，不用再花時間繪出畫面。

### 分割圖層
由佈局樹產生圖層樹，不是一個元素一個圖層最好，這樣反而可能會拖慢速度。

### 合成與柵格化
在合成執行緒合成好要顯示的畫面之後，交由光柵執行緒執行「柵格化」（計算出一個一個格子裡面應該影示的顏色、亮度……），光柵執行緒會把這些資料傳到圖型處理器的記憶體中。
接著合成執行緒會把柵格化的資訊再搜集起來，建立一個「合成框」，再將這個「合成框」傳給瀏覽器執行緒之後轉交給圖型處理器最後顯示在螢幕上。

「合成」有一個好處就是它不必經過渲染程序的主執行緒，不必等待樣式計算或 JavaScript 的執行，這也是為什麼「獨立合成動畫」[compositing only animations](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/) 是優化顯示效能的好辦法。
