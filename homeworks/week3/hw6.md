# 解題心得

因為之前上 ALG101 的時候都寫過了，所以沒有特別的難，這次寫作業的時候也試著自已把前面引入 readline 模組，以及建立讀取資料介面、存入資料至陣列再呼叫解題函式的部分不用複製貼上，全部自已寫出來，也比較熟悉 readline 這個模組怎麼應用了。  
但是這裡還是有一個問題，就是在 readline.createInterface() 裡面，會直接放一個大括號，這裡算是傳入參數嗎？（然後我自已再看一次就想通了，原來就是傳一個物件進去，問題還是留著當作記錄。）  

## hw1：好多星星

這題我自已是覺得沒有特別的難度，就是把雙層迴圈弄清楚就好。

## hw2：水仙花數

最大的收獲應該是學會「自戀」這個英文單字：narcissistic, 原來字源是來自希臘神話一個名為：Νάρκισσος（唸出來像：那爾奇索斯）的人，英文的水仙花也真的是同一個詞源。（然後還可以連結到 Ἠχώ （發音像：A 口）這個女神，從它的發音應該不難聯想到它的意思吧？！）
這一題在解的時候感覺沒有特別的難，可是實際寫出來的時候還是會有一些小地方沒有注意到：

1. 寫出有基本邏輯錯誤的迴圈, 如：

```javascript
while (i % 10 > 0) {
  sum += X
  i = Math.floor(1 / 10)
}
```

2. 忘記用另外一個變數存 n 的值，以致於 n 在經過迴圈之後都變成 0，後面的條件判斷就會出錯。  

然後第一次用 .toSTring().length 取得位數，也練習了用除法的方式取位數。  
試著用解構的寫法對變數賦值。  

## hw3：判斷質數

這題邏輯、程式碼的寫法沒有什麼問題，但是依然有不夠細心的問題，打錯字（readlind 打成 readlint），沒有注意題目提供的基本測資（1 不是質數）。  
迴圈的部分，因為每個數（n）都可以整除 1 所以直接從 2 開始嘗試就好，然後檢查到該數（n）的一半如果沒有滿足條件就可以確定一定是質數（但是我自已測試好像速度沒有比較快，甚至還慢了十幾毫秒……）  

## hw4：判斷迴文

在還沒看老師的解答之前，看到題目想說可以把字串分成兩部分做比對，就直接開始解了。  
與先把字串反轉再比對的結果是一樣的，複雜度應該也沒有差別。  

## hw5：聯誼順序比大小

注意數字會到 512 位數，本來也是直接用 BigInt 來解。  
不用 BigInt 的解法就是用比較字串的方法，先另外建立一個函式用來比較字串裡面的「數字」大小，兩個字串如果長度不同，一定是長的比較大，如果長度相同，則從字串的 index 0 開始（數字的最高位數）一位一位比較大小，只要找到其中一位比較大的就是那個字串比較大。  


## 超級挑戰題 貪婪的小偷 part 2
## 程式麻瓜解題過程

我清楚自已的腦力、智力、能力，沒有很強的邏輯能力、記憶力也不太行、更沒辦法舉一反三，所以只能靠找資料以及不斷練習來增進程式能力，這題當然也不例外。

雖然是順利的在 LidemyOJ 上拿到 AC 但是也不能算是完全靠自已的能力解出來，而是在查過很多背包問題、Dynamic Programming 相關的解釋之後，大概瞭解了背包問題的解法，才能把這些算法轉換為程式碼。

解這題對我自已來說可以分成三個階段：

1. 確實瞭解題目的意思  
嗯，其實算是在提醒我自已……因為我剛開始還蠢蠢的以為把可以丟進去的東西丟進去，減去重量，最後把價值加起來就好，真的有夠蠢。

2. 看懂「背包問題」  
順著老師給的關鍵字到網路上找資料，看到很多相關的教學，大部分都看不懂，直到找到 Coursera 上面墨爾本大學的這個課程[Discrete Optimization](https://www.coursera.org/learn/discrete-optimization/lecture/ZF8ds/knapsack-3-modeling)，第二週就是在講背包問題。剛開始看覺得這個教授 (Professor Pascal Van Hentenryck) 也太激動……但是發現他的講解真的很清楚，看完 dynamic programming 那個部分真的就瞭解原理是什麼了。（所以也就沒有繼續往下看，他後面還會講到其它的算法應用，有空再把它們看完吧！）

3. 演算法轉換為程式碼  
轉換為程式碼的方法其實並不太難，但是在過程中也是要注意一些細節。

## 背包問題

背包問題的原始內容很簡單：  
1. 一個可以裝進 W 公斤物品的背包  
2. N 項不可分割的物品  
3. 第 i 項物品有其自身的重量 Wi 及價格 Pi 
4. 試著在背包裡裝入價值最高的物品組合。  

## 不夠貪婪的幾個貪婪演算法

1. 從價格最高的開始拿（拿最貴）  

2. 從重量最小的開始拿（拿最多數量）  

3. 選單位價值晚最高（拿價值密度高）  

顯然，這幾種貪婪演算法都不夠貪婪，在很多情況下得到的都不是最好的結果，這時候就是 Dynamic Programming（動態規劃）派上用場的時候了。  

## Dynamic Programming 動態規劃

## 大事化小、小事化無
就是把每個問題裡的元素單獨處理，每次加上一個元素，與之前計算出來的最佳結果比較。  

這部分真的很難用筆記寫下來，之後會試著寫成一篇文章，目前可以先參考我在[程式碼裡面的註解](./challenges/Ch2_knapsack.js)。  
